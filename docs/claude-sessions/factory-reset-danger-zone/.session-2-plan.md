# Session 2 Implementation Plan -- Factory Reset Backend

## Goal

Implement the authenticated live factory-reset backend endpoint that clears
all Tuitbot-managed data (30 DB tables, config files, media, in-memory state)
and returns the instance to an unconfigured state -- without requiring a
server restart.

---

## Files to Create

| # | File | Purpose |
|---|------|---------|
| 1 | `crates/tuitbot-core/src/storage/reset.rs` | Core DB clearing logic: `factory_reset(pool) -> Result<ResetStats>` |
| 2 | `crates/tuitbot-server/tests/factory_reset.rs` | Integration tests for the factory-reset endpoint |
| 3 | `docs/roadmap/factory-reset-danger-zone/reset-contract.md` | API contract documentation for Session 3 |
| 4 | `docs/roadmap/factory-reset-danger-zone/session-02-handoff.md` | Session handoff |

## Files to Modify

| # | File | Change |
|---|------|--------|
| 5 | `crates/tuitbot-core/src/storage/mod.rs` | Add `pub mod reset;` |
| 6 | `crates/tuitbot-server/src/routes/settings.rs` | Add `factory_reset` handler + request/response types |
| 7 | `crates/tuitbot-server/src/lib.rs` | Add route: `.route("/settings/factory-reset", post(...))` |

---

## Exact Order of Operations

### Step 1: Create `crates/tuitbot-core/src/storage/reset.rs`

This is the core DB-clearing function. It lives in the storage layer (L1)
because it only performs DELETE queries -- no X API, no LLM, no workflow.

**Design:**

```rust
use super::DbPool;
use crate::error::StorageError;

/// Statistics returned from a factory reset operation.
#[derive(Debug, Clone, serde::Serialize)]
pub struct ResetStats {
    /// Number of tables cleared.
    pub tables_cleared: u32,
    /// Total number of rows deleted across all tables.
    pub rows_deleted: u64,
}

/// FK-safe table deletion order. Children before parents.
const TABLES_TO_CLEAR: &[&str] = &[
    // FK-constrained tables (children first)
    "draft_seeds",
    "original_tweets",
    "content_nodes",
    "thread_tweets",
    "account_roles",
    "target_tweets",
    "approval_edit_history",
    // No FK constraints below
    "reply_performance",
    "tweet_performance",
    "replies_sent",
    "discovered_tweets",
    "threads",
    "approval_queue",
    "scheduled_content",
    "target_accounts",
    "follower_snapshots",
    "content_scores",
    "strategy_reports",
    "rate_limits",
    "action_log",
    "cursors",
    "author_interactions",
    "media_uploads",
    "llm_usage",
    "x_api_usage",
    "mcp_telemetry",
    "mutation_audit",
    "source_contexts",
    "sessions",
    "accounts",
];

/// Clear all user data from the database within a single transaction.
///
/// Deletes all rows from 30 user tables in FK-safe order.
/// Preserves the schema (tables, indexes) and `_sqlx_migrations`.
pub async fn factory_reset(pool: &DbPool) -> Result<ResetStats, StorageError> {
    let mut tx = pool
        .begin()
        .await
        .map_err(|e| StorageError::Connection { source: e })?;

    let mut rows_deleted: u64 = 0;
    let mut tables_cleared: u32 = 0;

    for table in TABLES_TO_CLEAR {
        let query = format!("DELETE FROM {table}");
        let result = sqlx::query(&query)
            .execute(&mut *tx)
            .await
            .map_err(|e| StorageError::Query { source: e })?;
        rows_deleted += result.rows_affected();
        tables_cleared += 1;
    }

    tx.commit()
        .await
        .map_err(|e| StorageError::Connection { source: e })?;

    Ok(ResetStats {
        tables_cleared,
        rows_deleted,
    })
}
```

**Key decisions:**

1. **Single transaction**: All 30 DELETE statements run inside one SQLite
   transaction. If any fails, the entire reset rolls back -- no partial state.

2. **`format!("DELETE FROM {table}")` safety**: The table names come from a
   compile-time `&[&str]` constant, not user input. No SQL injection risk.
   SQLx does not support parameterized table names, so string formatting is
   the standard approach (same pattern used throughout the codebase).

3. **No VACUUM in the transaction**: VACUUM cannot run inside a transaction
   and holds an exclusive lock. Decision (from open issue #1 in handoff):
   **skip VACUUM entirely**. Rationale: SQLite reuses freed pages for future
   inserts, so disk space is reclaimed on re-onboard. A factory reset is a
   rare operation and immediate disk reclamation is not worth the exclusive
   lock risk. If needed, users can VACUUM via the CLI.

4. **Unit tests**: Add `#[cfg(test)]` module with:
   - `factory_reset_clears_all_tables` -- insert sample rows, reset, verify
     zero rows in each table.
   - `factory_reset_preserves_migrations` -- verify `_sqlx_migrations` is
     untouched after reset.
   - `factory_reset_returns_accurate_stats` -- verify row counts match
     expected deletions.
   - `factory_reset_idempotent` -- reset on already-empty DB succeeds with
     0 rows deleted.

### Step 2: Register the module in `crates/tuitbot-core/src/storage/mod.rs`

Add `pub mod reset;` to the module list (alphabetical placement after
`rate_limits`).

### Step 3: Add handler to `crates/tuitbot-server/src/routes/settings.rs`

The handler is a thin orchestrator -- it does not own business logic.

**New types:**

```rust
/// Confirmation phrase required for factory reset.
const FACTORY_RESET_PHRASE: &str = "RESET TUITBOT";

#[derive(Deserialize)]
pub struct FactoryResetRequest {
    confirmation: String,
}

#[derive(Serialize)]
struct FactoryResetResponse {
    status: String,
    cleared: FactoryResetCleared,
}

#[derive(Serialize)]
struct FactoryResetCleared {
    tables_cleared: u32,
    rows_deleted: u64,
    config_deleted: bool,
    passphrase_deleted: bool,
    media_deleted: bool,
    runtimes_stopped: u32,
}
```

**Handler logic (`pub async fn factory_reset`):**

```rust
pub async fn factory_reset(
    State(state): State<Arc<AppState>>,
    Json(body): Json<FactoryResetRequest>,
) -> Result<impl IntoResponse, ApiError> {
    // 1. Validate confirmation phrase.
    if body.confirmation != FACTORY_RESET_PHRASE {
        return Err(ApiError::BadRequest(
            "incorrect confirmation phrase".to_string(),
        ));
    }

    // 2. Stop all runtimes (before DB clearing to prevent races).
    let runtimes_stopped = {
        let mut runtimes = state.runtimes.lock().await;
        let count = runtimes.len() as u32;
        for (_, mut rt) in runtimes.drain() {
            rt.shutdown().await;
        }
        count
    };

    // 3. Cancel watchtower.
    if let Some(ref token) = state.watchtower_cancel {
        token.cancel();
    }

    // 4. Clear all DB table contents (single transaction).
    let reset_stats = tuitbot_core::storage::reset::factory_reset(&state.db).await?;

    // 5. Delete config.toml (tolerate NotFound for idempotency).
    let config_deleted = match std::fs::remove_file(&state.config_path) {
        Ok(()) => true,
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => false,
        Err(e) => {
            tracing::warn!(error = %e, "failed to delete config file");
            false
        }
    };

    // 6. Delete passphrase_hash file (tolerate NotFound).
    let passphrase_path = state.data_dir.join("passphrase_hash");
    let passphrase_deleted = match std::fs::remove_file(&passphrase_path) {
        Ok(()) => true,
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => false,
        Err(e) => {
            tracing::warn!(error = %e, "failed to delete passphrase hash");
            false
        }
    };

    // 7. Delete media directory (tolerate NotFound).
    let media_dir = state.data_dir.join("media");
    let media_deleted = match std::fs::remove_dir_all(&media_dir) {
        Ok(()) => true,
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => false,
        Err(e) => {
            tracing::warn!(error = %e, "failed to delete media directory");
            false
        }
    };

    // 8. Clear in-memory state.
    *state.passphrase_hash.write().await = None;
    state.content_generators.lock().await.clear();
    state.login_attempts.lock().await.clear();

    tracing::info!(
        tables = reset_stats.tables_cleared,
        rows = reset_stats.rows_deleted,
        config = config_deleted,
        passphrase = passphrase_deleted,
        media = media_deleted,
        runtimes = runtimes_stopped,
        "Factory reset completed"
    );

    // 9. Build response with cookie-clearing header.
    let response = FactoryResetResponse {
        status: "reset_complete".to_string(),
        cleared: FactoryResetCleared {
            tables_cleared: reset_stats.tables_cleared,
            rows_deleted: reset_stats.rows_deleted,
            config_deleted,
            passphrase_deleted,
            media_deleted,
            runtimes_stopped,
        },
    };

    let cookie = "tuitbot_session=; HttpOnly; SameSite=Strict; Path=/; Max-Age=0";
    Ok((
        StatusCode::OK,
        [(axum::http::header::SET_COOKIE, cookie)],
        Json(serde_json::to_value(response).unwrap()),
    ))
}
```

**Design decisions for the handler:**

1. **No `AccountContext` extractor**: The factory reset is an instance-level
   operation (it deletes ALL accounts, not just one). Using `AccountContext`
   would scope it to a single account. Instead, the handler takes only
   `State(state)` and `Json(body)`. Auth is still enforced by the middleware
   (bearer or session+CSRF) -- this route is NOT in `AUTH_EXEMPT_PATHS`.

2. **Always set cookie-clearing header**: The `Set-Cookie` header with
   `Max-Age=0` is harmless for bearer callers (they don't use cookies) and
   necessary for cookie callers (their session was just deleted from the DB).

3. **Partial failure tolerance**: File deletions log warnings and continue.
   The response includes `config_deleted`, `passphrase_deleted`,
   `media_deleted` booleans so the caller knows what happened. The DB
   clearing is the critical path -- if it fails, the handler returns 500
   via the `?` operator before touching files.

4. **Runtime shutdown timeout**: Each `rt.shutdown().await` has a built-in
   30-second timeout per task (from the Runtime implementation). In practice,
   test runtimes have no spawned tasks, so this resolves instantly. In
   production, the worst case is 30s per task -- acceptable for a rare
   destructive operation.

5. **No WebSocket notification**: Per open issue #3 from handoff -- not
   required. Connected clients will 401 on their next API call (session
   deleted) and the frontend boot logic redirects to onboarding when
   `configured=false`. Adding a WsEvent is unnecessary complexity.

### Step 4: Add route to `crates/tuitbot-server/src/lib.rs`

Insert the route in the settings group, after `/settings/test-llm` and
before `/settings`:

```rust
.route("/settings/test-llm", post(routes::settings::test_llm))
.route(
    "/settings/factory-reset",
    post(routes::settings::factory_reset),
)
.route(
    "/settings",
    get(routes::settings::get_settings).patch(routes::settings::patch_settings),
)
```

**Placement rationale**: Literal path `/settings/factory-reset` must appear
before the parameterized or catchall `/settings` to avoid Axum route
conflicts (same pattern as `/approval/stats` before `/approval/{id}`).

### Step 5: Create integration tests `crates/tuitbot-server/tests/factory_reset.rs`

Follow the test patterns from `api_tests.rs` and `fresh_install_auth.rs`.

**Test helper:**

```rust
fn test_state_with_dir(dir: &Path, pool: DbPool) -> Arc<AppState> {
    // Build AppState with tempdir data_dir and config_path
    // Write a minimal config.toml to make config_path.exists() == true
    // Return Arc<AppState>
}
```

**Test cases:**

1. **`factory_reset_requires_auth`**: POST without token -> 401.
   Confirms the route is NOT in AUTH_EXEMPT_PATHS.

2. **`factory_reset_rejects_wrong_confirmation`**: POST with
   `{"confirmation": "wrong"}` -> 400 with error message.
   Also test empty string and case mismatch (`"reset tuitbot"`).

3. **`factory_reset_success`**: Full happy path:
   - Seed sample data in tables (at least accounts, target_accounts,
     discovered_tweets, approval_queue).
   - Write config.toml and passphrase_hash files in tempdir.
   - POST with correct phrase -> 200.
   - Verify response shape: `status == "reset_complete"`, `cleared` object.
   - Verify tables are empty (SELECT COUNT(*) on key tables).
   - Verify config.toml deleted.
   - Verify passphrase_hash deleted.
   - Verify Set-Cookie header clears session.

4. **`factory_reset_idempotent`**: Reset on already-reset instance:
   - First reset -> 200.
   - Second reset -> 200 with `rows_deleted: 0`.
   Confirms no errors on empty tables or missing files.

5. **`factory_reset_clears_config_status`**: After reset:
   - GET /api/settings/status -> `{"configured": false, "claimed": false}`.
   Confirms the frontend boot logic will redirect to onboarding.

6. **`factory_reset_cookie_clearing`**: Verify response includes
   `Set-Cookie: tuitbot_session=; ... Max-Age=0`.

7. **`factory_reset_allows_re_onboarding`**: After reset:
   - POST /api/settings/init with valid config -> 200 "created".
   Confirms the full reset-then-re-onboard cycle works.

---

## Key Design Decisions

| Decision | Rationale |
|----------|-----------|
| Skip VACUUM | Can't run inside tx; reused pages on re-insert; avoids exclusive lock on large DBs. Resolves open issue #1. |
| No `AccountContext` | Factory reset is instance-level, not account-scoped. Auth middleware still protects the route. |
| Always emit Set-Cookie clearing | Harmless for bearer; necessary for cookie callers. Simpler than detecting auth strategy. |
| Response includes per-step booleans | Resolves open issue #2: partial failure transparency without aborting the operation. |
| No WebSocket event | Frontend detects reset via 401 + `configured=false`. Resolves open issue #3. |
| `drain()` all runtimes | Resolves open issue #4: multi-account runtime clearing. |
| Table list as const array | Compile-time verified, no SQL injection, easy to audit against migration list. |

---

## Risks and Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Missed table in TABLES_TO_CLEAR | Data survives reset | Unit test queries sqlite_master for all non-migration tables and asserts they are all in the constant |
| Transaction too large for SQLite | DELETE on massive table blocks pool | SQLite WAL handles this well; pool of 4 means 3 other connections can read. Acceptable for rare operation. |
| Runtime shutdown hangs | Handler blocks for 30s per task | Built-in timeout in Runtime::shutdown(). Log and continue. |
| File deletion after DB commit | Config/passphrase survive if I/O fails | Response reports per-step success; log warnings; files are re-deleted on next reset attempt (idempotent). |
| Auth race (session deleted mid-request) | Other concurrent requests from same session may fail | Acceptable: factory reset is intentionally destructive. Sessions table cleared in transaction. |
| Bearer token in `api_token` file | Must NOT be deleted | Explicit exclusion: not in file deletion list. api_token stays in AppState. |

---

## Verification Steps

### During Implementation

After each file is created/modified, run:

```bash
cargo fmt --all
cargo clippy --workspace -- -D warnings
```

### Final Quality Gates

```bash
# Full CI checklist (must all pass before handoff)
cargo fmt --all && cargo fmt --all --check
RUSTFLAGS="-D warnings" cargo test --workspace
cargo clippy --workspace -- -D warnings
```

### Specific Test Runs

```bash
# Core unit tests only
cargo test -p tuitbot-core storage::reset

# Integration tests only
cargo test -p tuitbot-server factory_reset
```

---

## Implementation Sequence (exact order)

1. Create `crates/tuitbot-core/src/storage/reset.rs` with `ResetStats`,
   `TABLES_TO_CLEAR`, `factory_reset()`, and `#[cfg(test)]` module.
2. Add `pub mod reset;` to `crates/tuitbot-core/src/storage/mod.rs`.
3. Run `cargo test -p tuitbot-core storage::reset` -- verify unit tests pass.
4. Add request/response types and `factory_reset` handler to
   `crates/tuitbot-server/src/routes/settings.rs`.
5. Add `.route("/settings/factory-reset", post(...))` to
   `crates/tuitbot-server/src/lib.rs`.
6. Run `cargo clippy --workspace -- -D warnings` -- fix any warnings.
7. Create `crates/tuitbot-server/tests/factory_reset.rs` with all 7 test
   cases.
8. Run `RUSTFLAGS="-D warnings" cargo test --workspace` -- all green.
9. Run `cargo fmt --all && cargo fmt --all --check` -- no diffs.
10. Write `docs/roadmap/factory-reset-danger-zone/reset-contract.md` with
    the finalized API contract for Session 3 to build against.
11. Write `docs/roadmap/factory-reset-danger-zone/session-02-handoff.md`.

---

## Deliverable Checklist

- [ ] `crates/tuitbot-core/src/storage/reset.rs` -- core logic + unit tests
- [ ] `crates/tuitbot-core/src/storage/mod.rs` -- module registration
- [ ] `crates/tuitbot-server/src/routes/settings.rs` -- handler + types
- [ ] `crates/tuitbot-server/src/lib.rs` -- route registration
- [ ] `crates/tuitbot-server/tests/factory_reset.rs` -- 7 integration tests
- [ ] `docs/roadmap/factory-reset-danger-zone/reset-contract.md`
- [ ] `docs/roadmap/factory-reset-danger-zone/session-02-handoff.md`
- [ ] `cargo fmt --all && cargo fmt --all --check` passes
- [ ] `RUSTFLAGS="-D warnings" cargo test --workspace` passes
- [ ] `cargo clippy --workspace -- -D warnings` passes
