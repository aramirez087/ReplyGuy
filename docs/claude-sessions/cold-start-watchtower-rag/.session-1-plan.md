# Session 1 Implementation Plan: Charter and Scope

## Objective

Audit the existing codebase and produce four deliverables under `docs/roadmap/cold-start-watchtower-rag/` that form the implementation charter for a local-first Watchtower plus analytics-weighted RAG system. No source code modifications in this session — documentation only.

## Deliverables

1. `docs/roadmap/cold-start-watchtower-rag/implementation-charter.md`
2. `docs/roadmap/cold-start-watchtower-rag/architecture-decisions.md`
3. `docs/roadmap/cold-start-watchtower-rag/test-strategy.md`
4. `docs/roadmap/cold-start-watchtower-rag/session-01-handoff.md`

---

## Codebase Audit Summary

### Current Architecture (what exists today)

**Three-Layer Model in tuitbot-core:**
- **L1 Toolkit** (`core/toolkit/`): Stateless X API wrappers (read, write, engage, media). Only depends on `&dyn XApiClient`.
- **L2 Workflow** (`core/workflow/`): Stateful composites: discover, draft, queue, publish, thread_plan, orchestrate. Uses DB + optional LLM. Calls Toolkit only.
- **L3 Autopilot** (`core/automation/`): Scheduled loops with jitter, circuit breaking, graceful shutdown. Calls Workflow + Toolkit.

**Relevant Existing Modules:**

| Module | Location | Relevance to Watchtower RAG |
|--------|----------|----------------------------|
| `context/author.rs` | `core/context/` | AuthorContext with interaction summaries, risk signals, topic affinity — reusable for RAG context assembly |
| `context/engagement.rs` | `core/context/` | EngagementRecommendation with 5 weighted factors, confidence scores — provides decision gate for RAG |
| `context/topics.rs` | `core/context/` | TopicSnapshot with performance classification (double_down, reduce, experiment, maintain) — drives topic selection |
| `content/generator.rs` | `core/content/` | ContentGenerator with system prompt composition including persona, brand voice, archetype/format injection — main generation surface for RAG enrichment |
| `content/frameworks.rs` | `core/content/` | ReplyArchetype (5), TweetFormat (7), ThreadStructure (4) — weighted random selection, format-avoidance |
| `workflow/draft.rs` | `core/workflow/` | Draft pipeline: fetch candidate → LLM generation → safety checks → confidence/risk assessment |
| `workflow/orchestrate.rs` | `core/workflow/` | Full cycle: discover → draft → queue with typed CycleInput/CycleReport |
| `storage/analytics.rs` | `core/storage/` | Performance scoring (reply_performance, tweet_performance, content_scores), incremental averages |
| `automation/content_loop.rs` | `core/automation/` | Epsilon-greedy topic selection (80% exploit, 20% explore), slot scheduling |
| `automation/discovery_loop.rs` | `core/automation/` | Round-robin keyword rotation, consecutive error tracking, schedule gates |
| `automation/mod.rs` | `core/automation/` | Runtime struct with CancellationToken + JoinHandle management, graceful shutdown |
| `config/types.rs` | `core/config/` | BusinessProfile with persona fields, StorageConfig, all serde Serialize+Deserialize |
| `server/state.rs` | `server/` | AppState with per-account runtimes, content_generators, event broadcast, circuit breaker |

**Database Schema (18 migrations through `20260228000018_sessions.sql`):**
- Multi-account isolation via `account_id` on every table (default: `00000000-0000-0000-0000-000000000000`)
- Performance tracking: `reply_performance`, `tweet_performance`, `content_scores` with incremental averages
- Content tables: `discovered_tweets`, `replies_sent`, `original_tweets`, `threads`, `thread_tweets`
- Tracking: `author_interactions`, `action_log`, `approval_queue`, `scheduled_content`
- Cost: `llm_usage`, `x_api_usage`, `mcp_telemetry`

**Config Precedence:** CLI flags > env vars (`TUITBOT_` prefix) > `config.toml` > built-in defaults

---

## Key Design Decisions to Document

### AD-1: Source Model — Adapter-based content source abstraction

**Context:** The epic requires a v1 that reads from a local Obsidian vault path, but must preserve an adapter boundary for future Google Drive integration.

**Decision:** Define a `ContentSource` trait with a v1 `LocalFileSource` implementation. The trait surface is:
```rust
#[async_trait]
pub trait ContentSource: Send + Sync {
    fn source_type(&self) -> &str;  // "local_fs", "google_drive", etc.
    async fn scan_for_changes(&self, since: Option<DateTime<Utc>>) -> Result<Vec<SourceFile>, SourceError>;
    async fn read_content(&self, path: &str) -> Result<String, SourceError>;
    async fn write_metadata(&self, path: &str, metadata: &LoopBackMetadata) -> Result<(), SourceError>;
}
```

**Rationale:**
- Matches the existing trait-based pattern (`XApiClient`, `LlmProvider`)
- `LocalFileSource` does filesystem I/O (read .md/.txt files from configured vault path)
- Future `GoogleDriveSource` implements same trait, swaps at config time
- Trait is in `core` (L2 workflow level) since it's stateful but not automation-level

**Config integration:** Add `[content_sources]` section to config:
```toml
[[content_sources]]
type = "local_fs"
path = "~/notes/obsidian-vault"
watch = true
file_patterns = ["*.md", "*.txt"]
```

### AD-2: Schema Evolution Strategy

**New migration:** `20260228000019_watchtower_ingestion.sql` (additive only)

**New tables:**
1. `source_contexts` — Registered content sources (type, path/URI, config, sync cursor)
2. `content_nodes` — Ingested content chunks (source_id FK, path, content_hash, extracted text, front-matter JSON, timestamps)
3. `draft_seeds` — Pre-computed hooks/angles from content nodes for draft generation (node_id FK, seed text, archetype suggestion, engagement_weight)

**Extended columns (additive ALTER TABLE):**
- `tweet_performance` + `reply_performance`: add `archetype_vibe TEXT` and `engagement_score REAL` for Winning DNA classification
- `original_tweets`: add `source_node_id INTEGER REFERENCES content_nodes(id)` for provenance tracking

**Rationale:** All changes are additive (new tables + new nullable columns). Existing queries are unaffected. No index changes to existing tables.

### AD-3: Layer Placement

| Component | Layer | Rationale |
|-----------|-------|-----------|
| `ContentSource` trait + `LocalFileSource` | Foundation (alongside `x_api`, `storage`, `llm`) | Stateless I/O adapter like XApiClient |
| `storage/watchtower.rs` | Foundation (storage) | CRUD for new tables, same pattern as `storage/analytics.rs` |
| `context/winning_dna.rs` | L2 Workflow (context submodule) | Queries DB + computes engagement-weighted retrieval — same level as `context/engagement.rs` |
| Draft enrichment (blend notes + winning ancestors) | L2 Workflow (`workflow/draft.rs` extension) | Adds RAG context to existing draft pipeline |
| `automation/watchtower.rs` | L3 Autopilot | Notify-driven file watcher loop, follows `content_loop.rs` patterns |
| `routes/ingest.rs` | Server (thin route) | POST /api/ingest — param parse → delegate → envelope |

### AD-4: Watchtower Runtime Pattern

**Decision:** Follow existing `Runtime` pattern — watchtower is a spawned task managed by the same `CancellationToken`.

- Use `notify` crate for filesystem events (debounced, cross-platform)
- Reuse `LoopScheduler` for interval-based scan fallback
- Share ingest pipeline between filesystem events and manual POST /api/ingest
- Write-back (loop-back) appends YAML front-matter to source file with tweet URL + publish date

### AD-5: Analytics-Weighted RAG (Winning DNA)

**Decision:** Classify historical tweets into archetype/vibe categories, compute engagement-weighted scores, and use these as retrieval weights for draft generation.

**Retrieval algorithm:**
1. For a given topic/archetype, query `content_nodes` matching topic keywords
2. Join with `draft_seeds` that have engagement scores from prior publications
3. Weight by `engagement_score * recency_decay` (exponential decay, half-life = 14 days)
4. Return top-K ancestors as context for LLM prompt
5. Newly ingested nodes with no engagement data get a baseline weight (configurable, default 0.5)

**Integration with `ContentGenerator`:** The RAG context is injected as an additional section in the system prompt, after persona context and before format constraints. This is additive — existing generation paths are unchanged.

---

## Implementation Sequence

### Session 01: Charter and Scope (this session — documentation only)
**Files created:**
- `docs/roadmap/cold-start-watchtower-rag/implementation-charter.md`
- `docs/roadmap/cold-start-watchtower-rag/architecture-decisions.md`
- `docs/roadmap/cold-start-watchtower-rag/test-strategy.md`
- `docs/roadmap/cold-start-watchtower-rag/session-01-handoff.md`

### Session 02: Schema and Ingest API
**Files created/modified:**
- `migrations/20260228000019_watchtower_ingestion.sql` — new tables + additive columns
- `crates/tuitbot-core/src/storage/watchtower.rs` — typed CRUD helpers
- `crates/tuitbot-core/src/storage/mod.rs` — wire `pub mod watchtower`
- `crates/tuitbot-core/src/config/types.rs` — add `ContentSourceConfig` section
- `crates/tuitbot-server/src/routes/ingest.rs` — POST /api/ingest handler
- `crates/tuitbot-server/src/routes/mod.rs` — wire `pub mod ingest`
- `crates/tuitbot-server/src/lib.rs` — register route in router
- `docs/roadmap/cold-start-watchtower-rag/session-02-handoff.md`

### Session 03: Watchtower Runtime and Loop-Back
**Files created/modified:**
- `crates/tuitbot-core/src/automation/watchtower.rs` — notify-driven watcher
- `crates/tuitbot-core/src/automation/mod.rs` — wire module + exports
- `crates/tuitbot-server/src/state.rs` — optional watchtower handle in AppState
- `crates/tuitbot-server/src/main.rs` — start/stop watchtower with runtime
- `crates/tuitbot-core/src/storage/watchtower.rs` — loop-back metadata write
- `docs/roadmap/cold-start-watchtower-rag/session-03-handoff.md`

### Session 04: Winning DNA Retrieval
**Files created/modified:**
- `crates/tuitbot-core/src/context/winning_dna.rs` — archetype classification + retrieval
- `crates/tuitbot-core/src/context/mod.rs` — wire module
- `crates/tuitbot-core/src/storage/analytics.rs` — engagement_score queries
- `crates/tuitbot-core/src/workflow/draft.rs` — RAG context injection into draft pipeline
- `crates/tuitbot-core/src/content/generator.rs` — accept optional RAG context in prompt
- `docs/roadmap/cold-start-watchtower-rag/rag-ranking.md` — scoring thresholds doc
- `docs/roadmap/cold-start-watchtower-rag/session-04-handoff.md`

### Session 05: Validation and Obsidian Shakeout
**Files created/modified:**
- `docs/architecture.md` — update with Watchtower layer
- `docs/configuration.md` — document `[content_sources]` config
- `docs/roadmap/cold-start-watchtower-rag/validation-report.md`
- `docs/roadmap/cold-start-watchtower-rag/session-05-handoff.md`

---

## Risk Register

### R1: `notify` crate cross-platform behavior
- **Risk:** `notify` may have inconsistent debounce behavior across macOS FSEvents, Linux inotify, and Windows ReadDirectoryChanges.
- **Impact:** Medium — could cause duplicate or missed ingestion events.
- **Mitigation:** Use `notify-debouncer-full` for cross-platform consistency. Add fallback interval scan (every 5 min) as safety net. Test with tempdir fixtures.

### R2: Large Obsidian vaults causing slow initial scan
- **Risk:** Users with 10K+ note vaults could experience slow startup.
- **Impact:** Low — initial scan is one-time and background.
- **Mitigation:** Use content_hash (SHA-256) to skip unchanged files. Paginate initial scan. Store last-scan cursor in `source_contexts.sync_cursor`.

### R3: Loop-back metadata corrupting user notes
- **Risk:** Writing metadata back to .md files could corrupt formatting or conflict with Obsidian sync.
- **Impact:** High — user data loss.
- **Mitigation:** Use YAML front-matter (standard Obsidian format). Idempotent writes (check before append). Parse existing front-matter before modifying. Add `loop_back_enabled` config flag (default: true, can disable).

### R4: RAG context bloating LLM token usage
- **Risk:** Including too many ancestors/notes in the system prompt could exceed token limits or inflate costs.
- **Impact:** Medium — cost and latency.
- **Mitigation:** Cap RAG context at 2000 tokens (configurable). Truncate ancestors to 120 chars each. Show estimated token count in draft response. Track RAG-specific token usage in `llm_usage`.

### R5: Schema migration breaking existing deployments
- **Risk:** Additive migration could fail if SQLite version doesn't support certain ALTER TABLE forms.
- **Impact:** Low — SQLite 3.35+ supports all needed operations.
- **Mitigation:** Test migration on fresh DB and on DB with existing data. Use only `ALTER TABLE ... ADD COLUMN` (supported since SQLite 3.2.0). Pre-migration backup already exists in `storage/mod.rs`.

### R6: Concurrent file-system writes during loop-back
- **Risk:** Watchtower detects its own loop-back writes as new changes, creating infinite loops.
- **Impact:** Medium — could cause runaway ingestion.
- **Mitigation:** Maintain a set of "recently written" paths with a 5-second cooldown. Filter out events for paths in cooldown set. The content_hash check provides a second safety net.

---

## Test Strategy Summary

### Unit Tests (per module, deterministic, no I/O)

| Module | Tests |
|--------|-------|
| `storage/watchtower.rs` | CRUD lifecycle: insert source → insert node → insert seed → query seeds → update status |
| `context/winning_dna.rs` | Archetype classification from text patterns; engagement-weighted ranking with decay; edge cases (no data, all equal) |
| `config/types.rs` | ContentSourceConfig serde round-trip; validation of path/type fields; default values |
| Migration SQL | Apply on fresh `init_test_db()`, verify all new tables + columns exist |

### Integration Tests (in-memory SQLite, mock LLM)

| Test | Coverage |
|------|----------|
| Full ingest pipeline | File content → parse → store node → generate seed → verify DB state |
| Draft with RAG context | Mock LLM → verify system prompt contains ancestor context + note context |
| Engagement-weighted retrieval | Insert nodes with varying scores → verify ranking order |
| Loop-back idempotency | Write metadata twice → verify no duplication |

### End-to-End Tests (tempdir filesystem)

| Test | Coverage |
|------|----------|
| Watchtower file detection | Write .md to tempdir → verify content_node created after debounce |
| POST /api/ingest contract | HTTP request → verify 200 + DB state |
| Loop-back round-trip | Ingest → publish → verify metadata appended to source file |
| Ignored file patterns | Write .jpg to watched dir → verify no ingestion |

### Quality Gates (run every session)
```bash
cargo fmt --all && cargo fmt --all --check
RUSTFLAGS="-D warnings" cargo test --workspace
cargo clippy --workspace -- -D warnings
```

---

## Verification Steps for This Session

Since Session 01 produces only documentation:

1. **Directory created:** `docs/roadmap/cold-start-watchtower-rag/` exists with all 4 files.
2. **Charter completeness:** Every requirement mapped to specific module/file.
3. **Source model specificity:** Obsidian vault path configuration documented with TOML example.
4. **Handoff clarity:** Session 02 can execute without re-reading anchor files — all decisions, files, and migration names are explicit.
5. **No source code changes:** `git diff` shows only new files under `docs/`.

---

## Order of Operations

1. Create `docs/roadmap/cold-start-watchtower-rag/` directory.
2. Write `architecture-decisions.md` — AD-1 through AD-5 with full rationale, code sketches, and config examples.
3. Write `implementation-charter.md` — requirement-to-module mapping, session sequence, file manifest.
4. Write `test-strategy.md` — unit/integration/e2e test plan with specific function names and assertions.
5. Write `session-01-handoff.md` — exact files Session 02 creates, decisions already made, open questions resolved.
6. Verify all four files are self-consistent and reference each other correctly.

---

## Critical Constraints

- **No source code modifications.** Only documentation under `docs/roadmap/cold-start-watchtower-rag/`.
- **Additive only.** Migration uses only `CREATE TABLE` and `ALTER TABLE ... ADD COLUMN`.
- **Layer rules respected.** New modules placed at correct layer per architecture.md.
- **Single-process SQLite-first.** No external services required to boot.
- **Local-first.** v1 uses filesystem path; adapter boundary preserves future extensibility.
- **File size limits.** New .rs files ≤500 lines; split into submodules if exceeded.
