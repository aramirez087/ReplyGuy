# Session 09 — Capability-Based Source UX: Implementation Plan

## Mission

Wire the `DeploymentCapabilities` payload from `GET /api/runtime/status` into both the Settings and Onboarding source-configuration UIs so that:

- **Desktop** users see the native folder picker + manual path entry
- **Self-host** users see manual path entry (no native picker)
- **Cloud** users see only connector-first options (Google Drive); local filesystem affordances are hidden with explanatory copy

## Current State Summary

### Backend (ready — no changes needed)

- `GET /api/runtime/status` already returns `deployment_mode` and `capabilities` (5 boolean fields: `local_folder`, `manual_local_path`, `google_drive`, `inline_ingest`, `file_picker_native`)
- `Config.validate()` already rejects `local_fs` sources when `deployment_mode == Cloud`
- Frontend types (`DeploymentModeValue`, `DeploymentCapabilities`, `RuntimeStatus`) already exist in `dashboard/src/lib/api.ts:78-93`
- `api.runtime.status()` already wired at `api.ts:733`

### Frontend (all the work)

**ContentSourcesSection.svelte** (settings page):
- Lines 129-130: Unconditionally shows "Local Folder" and "Google Drive" in `<select>`
- Lines 149-154: Shows Browse button based on `isTauri` (should use `capabilities.file_picker_native`)
- Lines 137-166: Shows path input unconditionally for `local_fs` (should check `capabilities.manual_local_path`)
- No awareness of `DeploymentCapabilities`

**SourcesStep.svelte** (onboarding):
- Lines 86-88: Same unconditional dropdown with both source types
- Lines 105-110: Browse button behind `isTauri` only
- No capability awareness; defaults to `local_fs` even in cloud mode

**Onboarding store** (`stores/onboarding.ts`):
- Line 50: `source_type` defaults to `'local_fs'` regardless of deployment mode

**No runtime/capabilities store exists** — capabilities must be fetched and cached

---

## Design Decisions

### 1. Capabilities store: new `stores/runtime.ts`

**Decision:** Create a new `dashboard/src/lib/stores/runtime.ts` store that fetches and caches `RuntimeStatus` (including `deployment_mode` and `capabilities`).

**Rationale:**
- Settings store (`stores/settings.ts`) is config-focused; mixing runtime status in there conflates concerns
- Multiple components need capabilities (settings page, onboarding page, possibly future pages)
- A dedicated store follows the existing pattern (one store per domain: auth, analytics, activity, etc.)
- The store will export individual derived stores for convenience: `capabilities`, `deploymentMode`
- Fetch once on first access (lazy singleton); cache until page reload

**Alternative rejected:** Passing capabilities as props from parent pages. This works for settings (one parent) but is awkward for onboarding where the step components are deeply nested and the parent doesn't otherwise need runtime status.

### 2. Replace `isTauri` detection with capability-based checks

**Decision:** Replace the dynamic `@tauri-apps/plugin-dialog` import detection with `capabilities.file_picker_native` from the runtime store.

**Rationale:**
- `isTauri` is a platform detection heuristic; `file_picker_native` is a semantic capability
- This correctly handles the (hypothetical future) case where Tauri is detected but deployment mode is overridden to `cloud`
- The browse button should be gated on `file_picker_native`, not on whether the import succeeded
- Keep the dynamic `import('@tauri-apps/plugin-dialog')` inside `browseFolder()` (lazy-load the actual dialog code), but remove it from `onMount` detection

### 3. Cloud users: connector-first UX with informational message

**Decision:** When `capabilities.local_folder` is false:
- Remove "Local Folder" from the source type `<select>` entirely (not just disabled)
- Auto-select `google_drive` as the default
- Show an informational banner explaining why local filesystem is unavailable
- The message reads: "Local folder sources are not available in cloud deployments. Use Google Drive or another cloud connector."

**Rationale:**
- Disabled options with tooltips are harder to discover and understand
- Removing the option entirely prevents confusion
- The informational message provides context without being intrusive

### 4. Self-host: manual path, no Browse

**Decision:** When `capabilities.manual_local_path` is true but `capabilities.file_picker_native` is false:
- Show the text input for path entry
- Hide the "Browse" button
- Adjust hint text to say "Enter the full server-side path to your notes folder"

### 5. Onboarding default source type: capability-aware

**Decision:** The onboarding `SourcesStep` will check capabilities on mount and switch `source_type` to `google_drive` if `capabilities.local_folder` is false.

**Rationale:**
- The onboarding store defaults `source_type` to `local_fs` (line 50 of `stores/onboarding.ts`)
- We should NOT change the store's default (it's a static initial value)
- Instead, `SourcesStep.svelte` will read capabilities and override the local state on mount if needed
- This keeps the store generic and the capability logic in the component

### 6. No changes to backend or Tauri Cargo.toml

**Decision:** The backend is fully ready. No Rust code changes required for this session. The Tauri `lib.rs` and `Cargo.toml` do not need changes since the dialog plugin registration and AppState construction are already correct.

**Rationale:**
- `GET /api/runtime/status` returns capabilities
- Validation catches invalid source types on save
- `DeploymentMode` defaults to `Desktop` in Tauri context (correct behavior)
- `tauri_plugin_dialog::init()` is already registered

---

## Files to Create/Modify

| File | Action | Description |
|------|--------|-------------|
| `dashboard/src/lib/stores/runtime.ts` | **CREATE** | New store: fetches and caches deployment capabilities |
| `dashboard/src/routes/(app)/settings/ContentSourcesSection.svelte` | **MODIFY** | Gate source options, Browse button, and path input on capabilities |
| `dashboard/src/lib/components/onboarding/SourcesStep.svelte` | **MODIFY** | Gate source options and Browse button on capabilities; add cloud explainer |
| `docs/roadmap/cold-start-watchtower-rag/session-09-handoff.md` | **CREATE** | Session handoff document |

**Files explicitly NOT changed** (no backend work this session):
- `crates/tuitbot-server/src/routes/runtime.rs` — already returns capabilities
- `crates/tuitbot-server/src/routes/settings.rs` — already validates
- `dashboard/src-tauri/src/lib.rs` — no new Tauri commands needed
- `dashboard/src-tauri/Cargo.toml` — no new dependencies
- `dashboard/package.json` — no new npm dependencies
- `dashboard/src/lib/api.ts` — types already exist
- `dashboard/src/routes/onboarding/+page.svelte` — no changes needed (SourcesStep handles itself)

---

## Implementation Order

### Step 1: Create `dashboard/src/lib/stores/runtime.ts`

Create a new Svelte store that:
1. Exports a `loadCapabilities()` async function that calls `api.runtime.status()`
2. Exports writable stores: `runtimeStatus`, `capabilities`, `deploymentMode`
3. Exports a derived `capabilitiesLoaded` boolean
4. Includes a guard to only fetch once (idempotent re-calls are no-ops)

```typescript
// Sketch:
import { writable, derived } from 'svelte/store';
import { api, type RuntimeStatus, type DeploymentCapabilities, type DeploymentModeValue } from '$lib/api';

export const runtimeStatus = writable<RuntimeStatus | null>(null);
export const capabilities = derived(runtimeStatus, ($rs) => $rs?.capabilities ?? null);
export const deploymentMode = derived(runtimeStatus, ($rs) => $rs?.deployment_mode ?? 'desktop');
export const capabilitiesLoaded = derived(runtimeStatus, ($rs) => $rs !== null);

let fetching = false;
let fetched = false;

export async function loadCapabilities(): Promise<void> {
    if (fetched || fetching) return;
    fetching = true;
    try {
        const status = await api.runtime.status();
        runtimeStatus.set(status);
        fetched = true;
    } catch {
        // Fallback: assume desktop (backwards compat)
        runtimeStatus.set({
            running: false,
            task_count: 0,
            deployment_mode: 'desktop',
            capabilities: {
                local_folder: true,
                manual_local_path: true,
                google_drive: true,
                inline_ingest: true,
                file_picker_native: false, // safe default — no native picker assumed
            }
        });
        fetched = true;
    } finally {
        fetching = false;
    }
}
```

**Key detail — fallback on error:** If the API call fails (server not running yet, network issue), default to `desktop` mode with `file_picker_native: false`. This is safe because:
- Desktop users who get this fallback still see the manual path input
- The Browse button relies on the Tauri dynamic import anyway, so a false `file_picker_native` just hides it (the import would fail in non-Tauri context regardless)
- Cloud/self-host users should always have a running server, so the API call should succeed

### Step 2: Modify `ContentSourcesSection.svelte`

**Changes:**

1. **Import** the capabilities store and `loadCapabilities`:
   ```typescript
   import { capabilities, loadCapabilities } from '$lib/stores/runtime';
   ```

2. **Remove `isTauri` state** and the `onMount` Tauri detection block (lines 7, 22-29).

3. **Call `loadCapabilities()` in `onMount`** instead:
   ```typescript
   onMount(() => {
       loadCapabilities();
   });
   ```

4. **Derive available source types** from capabilities:
   ```typescript
   const canLocalFs = $derived($capabilities?.local_folder ?? true);
   const canManualPath = $derived($capabilities?.manual_local_path ?? true);
   const canNativePicker = $derived($capabilities?.file_picker_native ?? false);
   const canGoogleDrive = $derived($capabilities?.google_drive ?? true);
   ```

5. **Conditional `<select>` options** (lines 128-131):
   ```svelte
   <select id="source_type" class="text-input" value={sourceType} onchange={handleSourceTypeChange}>
       {#if canLocalFs}
           <option value="local_fs">Local Folder</option>
       {/if}
       {#if canGoogleDrive}
           <option value="google_drive">Google Drive</option>
       {/if}
   </select>
   ```

6. **Add cloud mode informational banner** below the select when `!canLocalFs`:
   ```svelte
   {#if !canLocalFs}
       <div class="capability-notice">
           Local folder sources are not available in cloud deployments. Use Google Drive or another cloud connector to provide content.
       </div>
   {/if}
   ```

7. **Gate Browse button** on `canNativePicker` instead of `isTauri` (line 149):
   ```svelte
   {#if canNativePicker}
       <button type="button" class="browse-btn" onclick={browseFolder}>
           <FolderOpen size={14} />
           Browse
       </button>
   {/if}
   ```

8. **Gate path input hint text** on mode:
   ```svelte
   <span class="field-hint">
       {#if canNativePicker}
           Click Browse to select your Obsidian vault or notes folder.
       {:else}
           Enter the full server-side path to your content folder.
       {/if}
   </span>
   ```

9. **Auto-switch source type** when capabilities load and current source type is unsupported:
   Add an `$effect` that detects if `sourceType === 'local_fs'` but `canLocalFs` is false, and calls `handleSourceTypeChange` to switch to `google_drive`.

10. **Add `.capability-notice` CSS** (styled similarly to `.field-hint` but with a subtle background):
    ```css
    .capability-notice {
        padding: 10px 14px;
        background: color-mix(in srgb, var(--color-accent) 8%, transparent);
        border: 1px solid color-mix(in srgb, var(--color-accent) 15%, transparent);
        border-radius: 6px;
        font-size: 12px;
        color: var(--color-text-subtle);
        line-height: 1.5;
    }
    ```

### Step 3: Modify `SourcesStep.svelte`

**Changes:**

1. **Import** the capabilities store:
   ```typescript
   import { capabilities, loadCapabilities } from '$lib/stores/runtime';
   ```

2. **Remove `isTauri` state and Tauri detection** (lines 13, 16-23).

3. **Call `loadCapabilities()` in `onMount`**:
   ```typescript
   onMount(() => {
       loadCapabilities();
   });
   ```

4. **Derive capability flags** (same as ContentSourcesSection):
   ```typescript
   const canLocalFs = $derived($capabilities?.local_folder ?? true);
   const canNativePicker = $derived($capabilities?.file_picker_native ?? false);
   const canGoogleDrive = $derived($capabilities?.google_drive ?? true);
   ```

5. **Auto-switch to google_drive** when cloud mode is detected:
   ```typescript
   $effect(() => {
       if ($capabilities && !$capabilities.local_folder && sourceType === 'local_fs') {
           sourceType = 'google_drive';
       }
   });
   ```

6. **Conditional `<select>` options** (lines 86-88):
   ```svelte
   <select id="source_type_select" class="text-input" bind:value={sourceType}>
       {#if canLocalFs}
           <option value="local_fs">Local Folder</option>
       {/if}
       {#if canGoogleDrive}
           <option value="google_drive">Google Drive</option>
       {/if}
   </select>
   ```

7. **Add cloud mode explanation** below the select:
   ```svelte
   {#if !canLocalFs}
       <p class="capability-hint">
           Local folder sources are not available in cloud deployments. Connect a Google Drive folder to provide your content.
       </p>
   {/if}
   ```

8. **Gate Browse button** on `canNativePicker` instead of `isTauri` (line 105):
   ```svelte
   {#if canNativePicker}
       <button type="button" class="browse-btn" onclick={browseFolder}>
           <FolderOpen size={14} />
           Browse
       </button>
   {/if}
   ```

9. **Add `.capability-hint` CSS**:
   ```css
   .capability-hint {
       font-size: 13px;
       color: var(--color-text-muted);
       margin: -12px 0 0;
       padding: 10px 14px;
       background: color-mix(in srgb, var(--color-accent) 6%, transparent);
       border-radius: 8px;
       line-height: 1.4;
   }
   ```

### Step 4: Verify `onboarding/+page.svelte` submit logic

**No code changes needed.** The submit logic at lines 93-119 already correctly branches:
- If `source_type === 'google_drive' && data.folder_id` → builds Google Drive config
- If `data.vault_path` → builds local_fs config
- Otherwise → no `content_sources` block at all

Since Step 3 ensures cloud users' `sourceType` is switched to `google_drive`, and the server validation catches any remaining mismatches, the submit logic is safe.

### Step 5: Create session handoff document

Write `docs/roadmap/cold-start-watchtower-rag/session-09-handoff.md` with:
- Summary of what was delivered
- Files changed
- CI results
- Design decisions
- Open items for Session 10

---

## Risks and Mitigations

### Risk 1: Race condition — capabilities not loaded when component renders

**Mitigation:** Derive capability flags with safe defaults (`?? true` for `local_folder`, `?? false` for `file_picker_native`). Components render immediately with defaults; when capabilities load, reactive `$derived` updates the UI. Desktop users see no flash (defaults match). Cloud/self-host users may see a brief flash of the local_fs option before it's removed — acceptable since the transition is fast and the select auto-switches.

### Risk 2: Onboarding page is unauthenticated — `GET /api/runtime/status` requires auth

**Investigation needed:** Check if `GET /api/runtime/status` is behind auth middleware. Looking at `routes/runtime.rs:21`, the handler takes `ctx: AccountContext` — this IS behind auth middleware. The onboarding page (where config doesn't exist yet) may not have an auth token.

**Mitigation plan:**
- Check if the onboarding page uses bearer auth or cookie auth
- If auth is required, the API call will fail, and the fallback in `loadCapabilities()` will default to `desktop` mode (safe for new installations since desktop is the default deployment mode)
- If we need to surface capabilities during onboarding for cloud/self-host, we have two options:
  1. Add a public capabilities endpoint (e.g., `GET /api/capabilities` without auth) — simple and safe since capabilities contain no secrets
  2. Add `capabilities` to the `/api/settings/status` response (which is already unauthenticated, per `settings.rs:110-113`)
- **Recommended:** Add `deployment_mode` and `capabilities` fields to `GET /api/settings/status` response. This endpoint is already public (used by the onboarding page to check if config exists). Adding two more fields is minimal and avoids a new endpoint.

**Implementation:** Add to `settings.rs`:
```rust
pub async fn config_status(State(state): State<Arc<AppState>>) -> Json<Value> {
    let configured = state.config_path.exists();
    let capabilities = state.deployment_mode.capabilities();
    Json(serde_json::json!({
        "configured": configured,
        "deployment_mode": state.deployment_mode,
        "capabilities": capabilities,
    }))
}
```

And update `api.ts` to add the response type and accessor. The runtime store's `loadCapabilities()` will try `api.runtime.status()` first (authenticated paths), then fall back to parsing capabilities from `api.settings.configStatus()` (unauthenticated paths).

### Risk 3: Svelte 5 reactivity — `$effect` ordering with store subscriptions

**Mitigation:** Use `$derived` for computed values from stores (not `$effect` writing to local state). The auto-switch `$effect` for cloud mode only runs once when capabilities load, writes to local `sourceType` state, and won't loop because the condition guards against re-triggering (`sourceType === 'local_fs'`).

### Risk 4: Breaking existing desktop workflow

**Mitigation:** All capability defaults (fallback values) preserve desktop behavior. If the API call fails, users get the same UI they have today. The Browse button's actual functionality still uses dynamic `import('@tauri-apps/plugin-dialog')` — the capability flag only controls visibility.

---

## Revised Implementation Order (incorporating Risk 2)

1. **Modify `settings.rs`** — add `deployment_mode` and `capabilities` to `GET /api/settings/status` response
2. **Update `api.ts`** — add capabilities fields to the `configStatus` response type; add a `getCapabilities()` helper that tries runtime status first, then config status
3. **Create `stores/runtime.ts`** — capabilities store with dual-fetch strategy
4. **Modify `ContentSourcesSection.svelte`** — capability-gated source options
5. **Modify `SourcesStep.svelte`** — capability-gated onboarding source step
6. **Run CI gates** — `cargo fmt`, `cargo clippy`, `cargo test`, `npm run check`
7. **Create `session-09-handoff.md`**

---

## Detailed File Changes

### 1. `crates/tuitbot-server/src/routes/settings.rs`

**Lines affected:** 109-113 (`config_status` function)

**Change:** Extend the JSON response to include `deployment_mode` and `capabilities`:

```rust
pub async fn config_status(State(state): State<Arc<AppState>>) -> Json<Value> {
    let configured = state.config_path.exists();
    let capabilities = state.deployment_mode.capabilities();
    Json(serde_json::json!({
        "configured": configured,
        "deployment_mode": state.deployment_mode,
        "capabilities": capabilities,
    }))
}
```

**Why:** This endpoint is unauthenticated and already called by the onboarding page. Adding capabilities here lets the onboarding flow know the deployment mode without requiring auth.

### 2. `dashboard/src/lib/api.ts`

**Lines affected:** Near line 78 (types) and near line 733 (api object)

**Changes:**
- Add `ConfigStatus` interface:
  ```typescript
  export interface ConfigStatus {
      configured: boolean;
      deployment_mode: DeploymentModeValue;
      capabilities: DeploymentCapabilities;
  }
  ```
- Update `api.settings.configStatus()` return type from `{ configured: boolean }` to `ConfigStatus`
- Find where `configStatus` is defined in the api object and update its type

### 3. `dashboard/src/lib/stores/runtime.ts` (NEW FILE)

Full implementation as described in Step 1 above, with the dual-fetch strategy:
- Try `api.runtime.status()` (authenticated)
- On failure, try parsing `api.settings.configStatus()` (unauthenticated)
- On all failures, fallback to desktop defaults

~40 lines total.

### 4. `dashboard/src/routes/(app)/settings/ContentSourcesSection.svelte`

**Lines affected:** 2-29 (script top), 128-131 (select options), 149-154 (Browse button), 157-161 (hint text)

**Changes detailed in Step 2 above.** Net line count change: ~+15 lines (add capability imports, derived vars, notice div, notice CSS; remove isTauri state and onMount detection).

### 5. `dashboard/src/lib/components/onboarding/SourcesStep.svelte`

**Lines affected:** 2-23 (script top), 86-88 (select options), 105-110 (Browse button)

**Changes detailed in Step 3 above.** Net line count change: ~+15 lines.

### 6. `docs/roadmap/cold-start-watchtower-rag/session-09-handoff.md` (NEW FILE)

Standard handoff format documenting what was delivered, CI results, design decisions, and Session 10 inputs.

---

## Verification Steps

### CI Gates (must all pass)

```bash
# Rust (only settings.rs changed)
cargo fmt --all && cargo fmt --all --check
RUSTFLAGS="-D warnings" cargo test --workspace
cargo clippy --workspace -- -D warnings

# Frontend
cd dashboard && npm run check
```

### Manual Verification Scenarios

1. **Desktop mode (default):**
   - Settings > Sources shows both "Local Folder" and "Google Drive" in dropdown
   - Selecting "Local Folder" shows path input with Browse button
   - Browse button opens native folder picker (Tauri dev only)
   - No capability notice shown

2. **Self-host mode** (`TUITBOT_DEPLOYMENT_MODE=self_host`):
   - Settings > Sources shows both "Local Folder" and "Google Drive"
   - Selecting "Local Folder" shows path input WITHOUT Browse button
   - Hint text says "Enter the full server-side path to your content folder"
   - No capability notice shown

3. **Cloud mode** (`TUITBOT_DEPLOYMENT_MODE=cloud`):
   - Settings > Sources shows only "Google Drive" in dropdown
   - Informational notice explains why local folder is unavailable
   - Source type auto-switches to `google_drive` if it was `local_fs`

4. **Onboarding (cloud mode):**
   - Sources step shows only "Google Drive" option
   - Explanatory text shown about cloud limitations
   - Submit creates config with `google_drive` source (or no source if unconfigured)

5. **API failure fallback:**
   - If server isn't running when page loads, UI defaults to desktop behavior
   - No errors shown to user; browse button hidden (safe default)

### Exit Criteria Verification

| Criterion | How to verify |
|-----------|---------------|
| Desktop users get native folder-picker | Run `npm run tauri:dev`, go to Sources, click Browse → native dialog opens |
| Self-host users can configure local path without native picker | Set `TUITBOT_DEPLOYMENT_MODE=self_host`, run server, go to Sources → text input visible, no Browse button |
| Cloud users not shown local filesystem affordances | Set `TUITBOT_DEPLOYMENT_MODE=cloud`, run server, go to Sources → only Google Drive shown, explanatory message visible |

---

## Test Coverage

### Rust (server-side)

Add 1-2 tests to `crates/tuitbot-server/tests/api_tests.rs`:

1. **`config_status_includes_capabilities`**: `GET /api/settings/status` returns `deployment_mode` and `capabilities` fields in JSON response.

2. **`config_status_capabilities_match_mode`**: Set `deployment_mode` to `Cloud` on AppState, verify response `capabilities.local_folder` is `false`.

### Frontend (type-checking only)

No test framework exists in the dashboard. Verification is via:
- `npm run check` — TypeScript type-checking catches type mismatches
- `npm run build` — ensures the production build succeeds
- Manual testing of the three deployment mode scenarios

---

## Dependencies Between Steps

```
Step 1 (settings.rs)
    ↓
Step 2 (api.ts types)
    ↓
Step 3 (stores/runtime.ts)
    ↓
Step 4 (ContentSourcesSection.svelte) ─── can run in parallel ─── Step 5 (SourcesStep.svelte)
    ↓                                                                  ↓
    └──────────────────── Step 6 (CI gates) ───────────────────────────┘
                              ↓
                    Step 7 (session-09-handoff.md)
```

Steps 4 and 5 are independent and can be done in either order (both depend on Step 3).
