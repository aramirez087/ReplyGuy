# Session 04 Plan — Validation and Release Readiness

**Date:** 2026-02-28
**Branch:** `feat/init_improvements`
**Goal:** Validate end-to-end fresh-install auth UX, close small gaps, and publish a go/no-go release-readiness report.

---

## Prerequisites — Read Before Starting

All of these have been read during planning:

- `docs/roadmap/fresh-install-auth-ux/charter.md` — full charter with 6 design decisions
- `docs/roadmap/fresh-install-auth-ux/backend-contract.md` — API contract
- `docs/roadmap/fresh-install-auth-ux/session-01-handoff.md` — charter session
- `docs/roadmap/fresh-install-auth-ux/session-02-handoff.md` — backend session
- `docs/roadmap/fresh-install-auth-ux/session-03-handoff.md` — frontend session

---

## Phase 1: Run Quality Gates (First — Establish Baseline)

**Rationale:** Run the full CI suite first to confirm the codebase is clean before any validation work. If anything fails here, it's a pre-existing issue from Session 03 that must be triaged.

### Step 1.1: Rust CI checks

```bash
cargo fmt --all && cargo fmt --all --check
RUSTFLAGS="-D warnings" cargo test --workspace
cargo clippy --workspace -- -D warnings
```

**Expected:** All pass (Session 03 confirmed these pass).

### Step 1.2: Frontend CI checks

```bash
cd dashboard && npm run check
cd dashboard && npm run build
```

**Expected:** `check` passes with 0 errors (6 pre-existing warnings acceptable). `build` succeeds.

### Decision: If any gate fails
- If it's a trivial fix (formatting, unused import, minor type annotation), fix it immediately.
- If it's a substantive failure, document it as a blocker in the release-readiness report and proceed with validation.

---

## Phase 2: Verify Implementation Against Charter

Systematically compare the charter's target UX and design decisions against the actual implementation.

### Step 2.1: Verify Charter Target UX — Fresh Install Web/LAN

**Charter specification (lines 103–116):**
```
Server starts → no passphrase_hash → +layout.svelte →
  1. No bearer token
  2. GET /api/settings/status → { configured: false, claimed: false }
  3. Redirect to /onboarding
  4. Complete wizard
  5. Final step: claim passphrase
  6. POST /api/settings/init with { ..config, claim: { passphrase } }
  7. Server creates config + hash atomically
  8. Response: Set-Cookie + csrf_token
  9. Dashboard
```

**Files to verify against:**
- `dashboard/src/routes/+layout.svelte` (lines 43–76) — web path checks config status first, redirects unconfigured to `/onboarding`
- `dashboard/src/routes/onboarding/+page.svelte` — web mode has 9 steps (last is "Secure"), submit includes claim payload
- `crates/tuitbot-server/src/routes/settings.rs` (`init_settings`) — claim extraction, validation, hash creation, session cookie
- `crates/tuitbot-server/src/main.rs` (lines 96–109) — localhost mode defers passphrase generation

**Verification checklist:**
- [ ] Layout gate: web path calls `configStatus()` before `checkAuth()` ✓ (lines 47-71)
- [ ] Unconfigured → redirect to `/onboarding` (not login) ✓ (lines 50-57)
- [ ] Onboarding shows 9 steps in web mode ✓ (`steps = $derived(isTauri ? BASE_STEPS : [...BASE_STEPS, 'Secure'])`)
- [ ] ClaimStep appears as step 9 ✓ (`currentStep === 8 && !isTauri`)
- [ ] Submit includes claim payload for web mode ✓ (lines 146-148)
- [ ] `settings.init()` uses `credentials: 'include'` ✓ (custom fetch in api.ts lines 882-893)
- [ ] Response `csrf_token` is stored via `claimSession()` ✓ (lines 158-161)
- [ ] Server creates hash atomically ✓ (settings.rs lines 226-263)
- [ ] Server returns Set-Cookie + csrf_token ✓ (settings.rs lines 247-263)
- [ ] Localhost mode skips passphrase generation ✓ (main.rs lines 96-109)

### Step 2.2: Verify Charter Target UX — Returning User (valid session)

**Charter specification (lines 118–124):**
```
Browser → +layout.svelte:
  1. No bearer token
  2. checkAuth() → session cookie valid
  3. Config check → configured
  4. Render dashboard
```

**Verification:**
- [ ] Layout checks config first → configured ✓ (line 48: `configStatus()`)
- [ ] Then `checkAuth()` for configured instances ✓ (line 60: `const hasSession = await checkAuth()`)
- [ ] Valid session → `connectWs()` → dashboard ✓ (lines 61-65)

### Step 2.3: Verify Charter Target UX — Returning User (expired session)

**Charter specification (lines 126–137):**
```
Browser → +layout.svelte:
  1. No bearer token
  2. checkAuth() → no valid session
  3. GET /api/settings/status → { configured: true, claimed: true }
  4. Redirect to /login
  5. Enter passphrase → authenticated → dashboard
```

**Verification:**
- [ ] Expired session: `checkAuth()` returns false → redirect to `/login` ✓ (lines 66-71)
- [ ] Login page shows "forgot passphrase?" section ✓ (login page lines 91-97)
- [ ] Context-aware error messages ✓ (login page lines 23-30)

**NOTE — Charter mismatch found:** The charter says step 2 is `checkAuth()` and step 3 is `configStatus()`, but the actual implementation calls `configStatus()` first (step 2) then `checkAuth()` (step 3). This is actually *better* — it avoids an unnecessary auth check on unconfigured instances. The charter's "Target UX" for returning users implies the auth check comes first, but the layout does config check first for ALL web users. The net behavior is identical for this scenario (configured instance → auth check → expired → login). **No code change needed — this is a documentation alignment item.**

### Step 2.4: Verify Charter Target UX — Tauri User (unchanged)

**Charter specification (lines 139–145):**
```
Bearer token → always authenticated
Config check → configured or not → onboarding or dashboard
No passphrase interaction
```

**Verification:**
- [ ] Tauri path: get token → setToken/setAuthMode/connectWs → config check ✓ (layout lines 27-42)
- [ ] Onboarding shows 8 steps in Tauri mode ✓ (`isTauri ? BASE_STEPS : ...`)
- [ ] No claim step for Tauri ✓ (`currentStep === 8 && !isTauri` guard)

### Step 2.5: Verify Charter Design Decisions

| # | Decision | Charter Reference | Implementation | Status |
|---|----------|-------------------|----------------|--------|
| 1 | Instance claiming via `/settings/init` | Lines 151-159 | `settings.rs` extracts `claim`, creates hash+session atomically | ✓ |
| 2 | Frontend gate reordering | Lines 161-169 | `+layout.svelte` web path: configStatus → auth | ✓ |
| 3 | Session bootstrap at claim time | Lines 171-179 | `claimSession()` mirrors `login()` | ✓ |
| 4 | Client-side passphrase generation | Lines 181-189 | `wordlist.ts` + `ClaimStep.svelte` | ✓ |
| 5 | Deferred passphrase for Tauri | Lines 191-198 | `isTauri` derived → step count conditional | ✓ |
| 6 | Conditional startup passphrase | Lines 200-211 | `main.rs` branches on `cli.host` | ✓ |

### Step 2.6: Verify Charter Security Model

| Property | Charter Promise | Implementation | Status |
|----------|----------------|----------------|--------|
| Hash only on disk | Yes | `create_passphrase_hash` writes bcrypt hash | ✓ |
| Plaintext never on disk | Yes | Client-side generation, only hash stored | ✓ |
| HttpOnly cookies | Yes | `HttpOnly; SameSite=Strict` in cookie string | ✓ |
| CSRF for mutating cookie-auth | Yes | Middleware checks `X-CSRF-Token` | ✓ |
| Rate limiting on login | Yes | `login_attempts` in AppState | ✓ |
| Bearer unchanged | Yes | Tauri path identical pre/post | ✓ |
| Init auth-exempt | Yes | `/settings/init` in AUTH_EXEMPT_PATHS | ✓ |
| One-shot claim (409) | Yes | `is_claimed()` check + 409 response | ✓ |

---

## Phase 3: Identify and Fix Small Gaps

Based on the thorough code review during planning, here are the specific issues found. Each is assessed for whether it fits within a single session.

### Gap 3.1: Edge case — config deleted but passphrase exists

**Issue (from Session 03 open items):** If `config.toml` is deleted but `passphrase_hash` exists, the layout sees `configured: false` and redirects to onboarding. The onboarding wizard will show the claim step (web mode), but the backend will reject the claim with 409 ("instance already claimed") because the hash file exists.

**Analysis:**
- `config_status` returns `{ configured: false, claimed: true }`
- Layout web path: `!status.configured` → redirect to `/onboarding`
- User fills onboarding → submit with claim → backend: claim check → `is_claimed()` → true → 409

**Fix options:**
1. **Frontend: skip claim step if `claimed: true`** — Check `claimed` status from `configStatus()` and conditionally include the claim step only when `!claimed`. This is the safest fix.
2. **Frontend: handle 409 gracefully on submit** — Catch the 409 from submit and show a message like "Passphrase already configured. You'll use your existing passphrase for future logins."

**Decision:** Implement **both**:
- Store the `claimed` status from `configStatus()` and pass it into the onboarding page (or make it available in a store).
- In onboarding `submit()`, handle 409 errors from the claim gracefully — strip the claim and retry without it, or show a clear error message.
- This handles both the fresh-navigation case (skip step) and the race condition case (409 handling).

**Implementation:**
- Modify `dashboard/src/routes/+layout.svelte`: pass `claimed` to onboarding via URL param or a shared store.
- Modify `dashboard/src/routes/onboarding/+page.svelte`: use claimed status to conditionally include claim step; add 409 handling in submit.

**Risk:** Low — additive change, no security implications.

### Gap 3.2: Layout gate — authenticated user on `/login` path redirect

**Issue:** When a web user has a valid session and navigates to `/login`, the layout redirects to `/` (line 64). This is correct. However, if a user has a valid session and navigates to `/onboarding`, the layout does NOT redirect them away — it falls through to `ready = true` and renders onboarding.

**Analysis:** This is actually fine for the normal case — onboarding is only reachable for unconfigured instances (the layout redirects configured instances through the auth check → dashboard). But if a user manually types `/onboarding` in the URL on a configured+authenticated instance, they'd see the wizard again. The submit would fail with 409 (config already exists).

**Decision:** This is a cosmetic edge case. The 409 prevents any damage. Document as known behavior, don't fix.

### Gap 3.3: Login page subtitle inconsistency

**Issue:** The login page subtitle says "Enter your passphrase to access the dashboard." (line 53). This is correct for returning users. But the charter and docs describe two paths to having a passphrase: (a) set during onboarding claim, or (b) generated at startup for `--host 0.0.0.0`. The subtitle doesn't distinguish.

**Decision:** The current copy is fine — both paths result in the user having a passphrase they need to enter. No change needed.

### Gap 3.4: `lan-mode.md` minor wording check

**Issue:** The `lan-mode.md` doc was updated in both Session 02 and Session 03. Need to verify it's internally consistent.

**Verification items:**
- Line 12: "prints it to the terminal" — correct for `--host 0.0.0.0` mode
- Lines 25-36: "First-Time Setup (Browser)" section — correctly describes claim flow
- Lines 43-50: "How It Works" section — correctly describes dual auth
- Lines 69-75: "Forgot your passphrase?" — correctly shows `--reset-passphrase`
- Lines 125-142: "Upgrading from a Previous Version" — describes legacy behavior

**Possible fix:** Line 50 says "On subsequent visits, if your session has expired, you'll see a login screen where you enter the same passphrase." This is accurate. No change needed.

### Gap 3.5: Onboarding progress bar crowding with 9 steps

**Issue (from Session 03 open items):** At narrow viewports, 9 step labels may overflow.

**Analysis:** This is a cosmetic concern. The progress bar uses `flex: 1` for the lines between steps. At very narrow viewports, the labels will truncate or wrap. Looking at the CSS:
- `.progress-label` has `white-space: nowrap` and `font-size: 11px`
- At ~320px viewport with 9 steps + 8 lines, each step gets ~35px which is tight

**Decision:** Not a blocker. Document as a follow-up item for responsive design improvement. The labels are short enough ("Welcome", "X API", etc.) that most real devices (375px+) will handle it.

---

## Phase 4: Reconcile Documentation

### Step 4.1: Verify backend-contract.md accuracy

Compare `docs/roadmap/fresh-install-auth-ux/backend-contract.md` against actual implementation in `settings.rs`.

**Items to check:**
- Response shape for claim success: `{ status: "created", config: {...}, csrf_token: "..." }` — matches settings.rs lines 254-263 ✓
- Cookie format: `tuitbot_session=<token>; HttpOnly; SameSite=Strict; Path=/; Max-Age=604800` — matches settings.rs lines 247-249 ✓
- Error responses: 400 for short passphrase (lines 168-171), 409 for already claimed (lines 173-175) ✓
- `claimed` field in status endpoint — matches settings.rs lines 124-133 ✓
- Startup behavior table — matches main.rs conditional logic (lines 78-109) ✓
- Core functions table: `is_claimed`, `create_passphrase_hash` — both exist in passphrase.rs ✓
- Error variant `AuthError::AlreadyClaimed` — exists in error.rs ✓

**Status:** Backend contract is accurate. No changes needed.

### Step 4.2: Verify charter accuracy against final implementation

The charter was written in Session 01 and describes intended behavior. The implementation may have deviated in small ways.

**Known deviation — layout gate ordering:**
- Charter says: "check config/claimed status *before* checking auth"
- Implementation: checks `configStatus()` first, then `checkAuth()` only for configured instances
- This is actually a refinement — unconfigured instances skip auth entirely. More efficient and more correct.
- **Action:** No code change. Note in release-readiness report.

**Known deviation — claim step position:**
- Charter says: "Final step: claim passphrase (generated client-side or user-chosen)"
- Implementation: step 9 "Secure" after step 8 "Review"
- Session 03 decided this (D2): user sees full config review before being asked for passphrase
- **Action:** Consistent with charter intent. No change needed.

---

## Phase 5: Write Deliverables

### Step 5.1: Create release-readiness report

**File:** `docs/roadmap/fresh-install-auth-ux/release-readiness.md`

**Structure:**
```markdown
# Release Readiness Report — Fresh-Install Auth UX

## Status: GO / NO-GO

## Scope of Change
- Summary of what Sessions 02-03 implemented

## Verification Results
### Quality Gates
- cargo fmt: ✅/❌
- cargo test: ✅/❌
- cargo clippy: ✅/❌
- npm run check: ✅/❌
- npm run build: ✅/❌

### Charter Compliance
- All 6 design decisions implemented
- All 4 target UX flows verified
- Security model preserved

### Test Coverage
- 8 integration tests (Session 02)
- Unit tests for passphrase module
- Frontend type checking passes

## Issues Found
### Fixed in This Session
- (list any Gap 3.x fixes)

### Known Issues (Non-Blocking)
- Progress bar crowding at narrow viewports
- Manual `/onboarding` navigation on configured instance shows wizard (409 prevents damage)

### Residual Risks
- First-claim race condition (two browsers simultaneously)
- Config-deleted-but-passphrase-exists edge case

## Recommended Follow-Up Work
- Passphrase strength indicator
- Custom passphrase show/hide toggle
- Responsive progress bar for 9-step wizard
- E2E automated test suite (Playwright)
```

### Step 5.2: Create session handoff

**File:** `docs/roadmap/fresh-install-auth-ux/session-04-handoff.md`

**Structure:**
```markdown
# Session 04 Handoff — Validation and Release Readiness

## What Changed
- (Any small fixes applied)
- Release readiness report published

## Design Decisions Made
- (Any decisions from this session)

## CI Results
- (Final CI run results)

## Open Issues
- (Any remaining items)

## Epic Status: COMPLETE
```

---

## Exact Order of Operations

1. **Run Rust CI gates** (`cargo fmt`, `cargo test`, `cargo clippy`)
2. **Run frontend CI gates** (`npm run check`, `npm run build`)
3. **Assess Gate results** — if failures, fix trivial ones, document blockers
4. **Verify charter compliance** — walk through each target UX flow and design decision against code
5. **Evaluate Gap 3.1** (config deleted but passphrase exists):
   - Read `+layout.svelte` to check if `claimed` status is propagated to onboarding
   - Read `onboarding/+page.svelte` to check 409 handling in submit
   - If the edge case is unhandled: implement the fix (skip claim step when `claimed: true`; handle 409 in submit)
   - Re-run CI after fix
6. **Review documentation** — `backend-contract.md`, `lan-mode.md` for accuracy
7. **Write `release-readiness.md`** with go/no-go determination
8. **Write `session-04-handoff.md`** as final epic closure
9. **Final CI run** to confirm clean state

---

## Files to Create

| File | Purpose |
|------|---------|
| `docs/roadmap/fresh-install-auth-ux/release-readiness.md` | Go/no-go release report |
| `docs/roadmap/fresh-install-auth-ux/session-04-handoff.md` | Final epic handoff |

## Files That May Be Modified (Only If Gaps Are Found)

| File | Potential Change | Condition |
|------|-----------------|-----------|
| `dashboard/src/routes/+layout.svelte` | Pass `claimed` status to onboarding | If Gap 3.1 needs fixing |
| `dashboard/src/routes/onboarding/+page.svelte` | Skip claim step when already claimed; handle 409 | If Gap 3.1 needs fixing |
| `docs/lan-mode.md` | Minor wording fixes | Only if inconsistencies found during doc review |

## Files That Will NOT Be Modified

- All Rust source files (`crates/`) — no backend changes expected
- `dashboard/src/lib/api.ts` — API layer is complete
- `dashboard/src/lib/stores/auth.ts` — auth store is complete
- `dashboard/src/lib/components/onboarding/ClaimStep.svelte` — claim UI is complete
- `dashboard/src/lib/wordlist.ts` — wordlist is complete

---

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| CI failures from pre-existing issues | Medium | Low | Session 03 confirmed clean. Fix or document. |
| Gap 3.1 fix introduces regression | Low | Low | Fix is additive (conditional step skip). Re-run CI. |
| Missed charter requirement | Medium | Very Low | Systematic verification above covers all 6 decisions and 4 flows. |
| Time overrun from unexpected issues | Low | Low | Session 04 is validation-only; no large features to implement. |

---

## Key Design Decisions for This Session

### D1: Config-deleted-but-passphrase-exists handling

The onboarding page should check `claimed` status from the layout/store and conditionally skip the claim step when the instance is already claimed but unconfigured. This prevents a confusing 409 error during an otherwise successful re-onboarding.

**Approach:** The layout already calls `configStatus()` which returns `{ configured, claimed }`. Pass the `claimed` boolean to the onboarding page. The `steps` array becomes:
- Tauri mode: 8 steps (no Secure)
- Web mode, unclaimed: 9 steps (with Secure)
- Web mode, already claimed: 8 steps (no Secure — passphrase already exists)

Additionally, the `submit()` function should handle 409 from claim gracefully as a fallback.

### D2: Release readiness criteria

A "GO" determination requires:
1. All 5 CI gates pass
2. All 6 charter design decisions verified in code
3. All 4 target UX flows verified in code
4. Security model preserved (no plaintext on disk, CSRF enforced, etc.)
5. No P0 blockers (blocking bugs that prevent core flows)

Non-blocking items (cosmetic, edge cases with safe fallbacks) can be documented as follow-up.
