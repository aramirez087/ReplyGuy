//! Implementation of the `tuitbot stats` command.
//!
//! Displays analytics dashboard: follower trend, top-performing topics,
//! engagement rates, and weekly volume.

use serde::Serialize;
use tuitbot_core::config::Config;
use tuitbot_core::storage;

use super::OutputFormat;
use crate::output::write_stdout;

#[derive(Serialize)]
struct FollowerSnapshotJson {
    date: String,
    follower_count: i64,
    following_count: i64,
    tweet_count: i64,
}

#[derive(Serialize)]
struct TopicJson {
    topic: String,
    format: String,
    total_posts: i64,
    avg_performance: f64,
}

#[derive(Serialize)]
struct EngagementJson {
    avg_reply_score: f64,
    avg_tweet_score: f64,
}

#[derive(Serialize)]
struct ContentMeasuredJson {
    replies: i64,
    tweets: i64,
}

#[derive(Serialize)]
struct StatsOutput {
    follower_trend: Vec<FollowerSnapshotJson>,
    net_follower_change: Option<i64>,
    top_topics: Vec<TopicJson>,
    engagement: EngagementJson,
    content_measured: ContentMeasuredJson,
}

/// Execute the `tuitbot stats` command.
pub async fn execute(config: &Config, output: OutputFormat) -> anyhow::Result<()> {
    let pool = storage::init_db(&config.storage.db_path).await?;

    if output.is_json() {
        let result = collect_stats_json(&pool).await;
        pool.close().await;
        let stats = result?;
        write_stdout(&serde_json::to_string(&stats)?)?;
        return Ok(());
    }

    eprintln!();
    eprintln!("=== Tuitbot Analytics ===");
    eprintln!();

    // 1. Follower trend (7 days)
    print_follower_trend(&pool).await;

    // 2. Top performing topics
    print_top_topics(&pool).await;

    // 3. Engagement rates
    print_engagement_rates(&pool).await;

    // 4. Performance counts
    print_performance_counts(&pool).await;

    eprintln!();

    pool.close().await;
    Ok(())
}

async fn collect_stats_json(pool: &storage::DbPool) -> anyhow::Result<StatsOutput> {
    let snapshots = storage::analytics::get_follower_snapshots(pool, 7)
        .await
        .unwrap_or_default();

    let net_follower_change = if snapshots.len() >= 2 {
        Some(snapshots[0].follower_count - snapshots[snapshots.len() - 1].follower_count)
    } else {
        None
    };

    let follower_trend: Vec<FollowerSnapshotJson> = snapshots
        .iter()
        .rev()
        .map(|s| FollowerSnapshotJson {
            date: s.snapshot_date.clone(),
            follower_count: s.follower_count,
            following_count: s.following_count,
            tweet_count: s.tweet_count,
        })
        .collect();

    let topics = storage::analytics::get_top_topics(pool, 10)
        .await
        .unwrap_or_default();
    let top_topics: Vec<TopicJson> = topics
        .into_iter()
        .map(|t| TopicJson {
            topic: t.topic,
            format: t.format,
            total_posts: t.total_posts,
            avg_performance: t.avg_performance,
        })
        .collect();

    let avg_reply_score = storage::analytics::get_avg_reply_engagement(pool)
        .await
        .unwrap_or(0.0);
    let avg_tweet_score = storage::analytics::get_avg_tweet_engagement(pool)
        .await
        .unwrap_or(0.0);

    let (replies, tweets) = storage::analytics::get_performance_counts(pool)
        .await
        .unwrap_or((0, 0));

    Ok(StatsOutput {
        follower_trend,
        net_follower_change,
        top_topics,
        engagement: EngagementJson {
            avg_reply_score,
            avg_tweet_score,
        },
        content_measured: ContentMeasuredJson { replies, tweets },
    })
}

async fn print_follower_trend(pool: &storage::DbPool) {
    eprintln!("--- Follower Trend (7 days) ---");

    match storage::analytics::get_follower_snapshots(pool, 7).await {
        Ok(snapshots) if snapshots.is_empty() => {
            eprintln!("  No data yet. Run the agent to collect snapshots.");
        }
        Ok(snapshots) => {
            // snapshots are newest first, reverse for chronological display
            for snap in snapshots.iter().rev() {
                eprintln!(
                    "  {} | Followers: {:>6} | Following: {:>5} | Tweets: {:>6}",
                    snap.snapshot_date, snap.follower_count, snap.following_count, snap.tweet_count
                );
            }

            if snapshots.len() >= 2 {
                let newest = &snapshots[0];
                let oldest = &snapshots[snapshots.len() - 1];
                let diff = newest.follower_count - oldest.follower_count;
                let sign = if diff >= 0 { "+" } else { "" };
                eprintln!(
                    "  Net change: {sign}{diff} followers over {} day(s)",
                    snapshots.len()
                );
            }
        }
        Err(e) => {
            eprintln!("  Error fetching snapshots: {e}");
        }
    }
    eprintln!();
}

async fn print_top_topics(pool: &storage::DbPool) {
    eprintln!("--- Top Performing Topics ---");

    match storage::analytics::get_top_topics(pool, 10).await {
        Ok(topics) if topics.is_empty() => {
            eprintln!("  No topic data yet.");
        }
        Ok(topics) => {
            for (i, topic) in topics.iter().enumerate() {
                eprintln!(
                    "  {}. {} (format: {}) | Posts: {} | Avg score: {:.1}",
                    i + 1,
                    topic.topic,
                    if topic.format.is_empty() {
                        "-"
                    } else {
                        &topic.format
                    },
                    topic.total_posts,
                    topic.avg_performance,
                );
            }
        }
        Err(e) => {
            eprintln!("  Error fetching topics: {e}");
        }
    }
    eprintln!();
}

async fn print_engagement_rates(pool: &storage::DbPool) {
    eprintln!("--- Engagement Rates ---");

    match storage::analytics::get_avg_reply_engagement(pool).await {
        Ok(avg) => eprintln!("  Avg reply score:  {avg:.1}"),
        Err(e) => eprintln!("  Reply engagement: error ({e})"),
    }

    match storage::analytics::get_avg_tweet_engagement(pool).await {
        Ok(avg) => eprintln!("  Avg tweet score:  {avg:.1}"),
        Err(e) => eprintln!("  Tweet engagement: error ({e})"),
    }

    eprintln!();
}

async fn print_performance_counts(pool: &storage::DbPool) {
    eprintln!("--- Content Measured ---");

    match storage::analytics::get_performance_counts(pool).await {
        Ok((replies, tweets)) => {
            eprintln!("  Replies measured: {replies}");
            eprintln!("  Tweets measured:  {tweets}");
        }
        Err(e) => {
            eprintln!("  Error fetching counts: {e}");
        }
    }
}
